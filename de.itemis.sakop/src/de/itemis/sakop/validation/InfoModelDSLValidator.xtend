/*
 * generated by Xtext 2.13.0
 */
package de.itemis.sakop.validation

import com.google.common.collect.HashMultimap
import de.itemis.sakop.infoModelDSL.DataItem
import de.itemis.sakop.infoModelDSL.Date
import de.itemis.sakop.infoModelDSL.Line
import de.itemis.sakop.infoModelDSL.RMax
import de.itemis.sakop.infoModelDSL.RMin
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import org.eclipse.xtext.validation.Check
import de.itemis.sakop.infoModelDSL.InfoModelDSLPackage

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class InfoModelDSLValidator extends AbstractInfoModelDSLValidator {
	
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					InfoModelDSLPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	
	public static val ISSUE_CODE_PREFIX = "org.itemis.sakop."
	public static val RESTRCITION_ERROR = ISSUE_CODE_PREFIX + "RestrictionError"
	public static val DUPLICATE_ELEMENT = ISSUE_CODE_PREFIX + "DuplicateElement"

	@Check
	def checkRestrictionsMax(RMax rmax){
		val max = Integer.parseInt(rmax.value)
		val otherRestrictions = (rmax.eContainer as DataItem).restrictions
		for(item : otherRestrictions){
			if(item instanceof RMin)
				if(Integer.parseInt((item as RMin).value) >= max){
					error(
						"Attribute 'max' should be greater than 'min'",
						InfoModelDSLPackage.Literals.RMAX__VALUE,
						RESTRCITION_ERROR
					)
				}
		}
	}
	
	@Check
	def checkUniqueRestrictions(DataItem item){
		if(item.hasRestrictions){
			var presentClasses = newLinkedHashSet()
			for(restriction : item.restrictions){
				if(!presentClasses.add(restriction.class)){
					error(
						"No duplicate restrictions allowed.",
						InfoModelDSLPackage.Literals.DATA_ITEM__RESTRICTIONS
					)
				}
			}
		}	
	}
	
	@Check
	def checkNoDuplicateMachines(Line line){
		val multiMap = HashMultimap.create()
		for(e : line.endpoints){
			multiMap.put(e.name, e)
		}
		for(entry:multiMap.asMap.entrySet){
			val duplicates = entry.value
			if(duplicates.size > 1){
				for (d : duplicates){
					error(
						"Duplicate machine " + d.name,
						d,
						InfoModelDSLPackage.eINSTANCE.line_Endpoints,
						DUPLICATE_ELEMENT
					)
				}
			}
		}
	}

	/**
	 * Checks if the name of a message is unique.
	 */
//	@Check
//	def ckeckMessageNameIsUnique(Message m){
//		var model = m.eContainer as InformationModel
//		for(other : model.parts) {
//			if(m.name == other.name && m != other) {
//				error("message names have to be unique", MachinePackage.Literals.MESSAGE__NAME)
//				return
//			}
//		}
//	}
	
	/**
	 * Checks if parsed date&time is valid value.
	 */
	@Check
	def checkDateFormat(Date date){
		/* check simple value restrictions / boundaries */
		if(date.y > 9999) {
			error("date: year is invalid", InfoModelDSLPackage.Literals.DATE__Y)
			return
		} else if(date.m > 12 || date.m == 0) {
			error("date: month is invalid", InfoModelDSLPackage.Literals.DATE__M)
			return
		} else if(date.d == 0 || date.d > 31){
			error("date: day is invalid", InfoModelDSLPackage.Literals.DATE__D)
			return
		} else if(date.h > 23){
			error("date: hour is invalid", InfoModelDSLPackage.Literals.DATE__H)
			return
		} else if(date.mi > 59){
			error("date: minute is invalid", InfoModelDSLPackage.Literals.DATE__MI)
			return
		} else if(date.s > 59){
			error("date: second is invalid", InfoModelDSLPackage.Literals.DATE__S)
			return
		}
		/* check if date is in future and therefore invalid */
		val dateString = date.y.toString + '-' +
						 date.m.toString + '-' +
						 date.d.toString + 'T' +
						 {if (date.h >= 10) date.h.toString else "0"+date.h.toString} + ':' +
						 {if (date.mi >= 10) date.mi.toString else "0"+date.mi.toString} + ':' +
						 {if (date.s >= 10) date.s.toString else "0"+date.s.toString} + ""
		if (LocalDateTime.now() < try{LocalDateTime.parse(dateString, DateTimeFormatter.ISO_LOCAL_DATE_TIME)}catch(IllegalArgumentException e){null}){
			error("date is invalid because it's in the future", InfoModelDSLPackage.Literals.DATE__Y)
			return
		}				 
	}
	
}
